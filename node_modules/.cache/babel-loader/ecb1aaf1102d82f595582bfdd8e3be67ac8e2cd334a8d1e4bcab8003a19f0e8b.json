{"ast":null,"code":"var Parser = module.exports = {};\nParser.extractFromFunction = function (func, multipleParams) {\n  // if function given is a function,\n  // extract the argument name, extract the return value,\n  // replace the argument name with 'x'\n  // return the return value as a string, with x as the independent variable\n  func = func.toString();\n  var args;\n  if (!multipleParams) {\n    var arg = func.match(/^function\\s*[^\\(]*\\(\\s*([^\\)\\,]*)[\\,\\)]/m)[1];\n    var regex = new RegExp('\\\\b' + arg.trim() + '\\\\b', 'g');\n    func = func.replace(regex, 'x');\n  } else {\n    // args are going to be f(x, a, b, c...) - x is independent variable, a, b... are parameters\n    args = func.match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)[\\)]/m)[1];\n    args = args.split(',');\n    var ch = 'a';\n    for (var i = 0; i < args.length; i++) {\n      var regex = new RegExp('\\\\b' + args[i].trim() + '\\\\b', 'g');\n      if (i === 0) {\n        func = func.replace(regex, 'x');\n      } else {\n        func = func.replace(regex, ch);\n        ch = String.fromCharCode(ch.charCodeAt(0) + 1);\n      }\n    }\n  }\n  func = func.match(/return\\s*([^\\;}]*)[\\;}]/m)[1];\n  args = args || {};\n  return {\n    func: func,\n    numArgs: args.length\n  };\n};\nParser.extractFromString = function (func, newVarName, multipleParams) {\n  if (newVarName && typeof newVarName === 'string' && !multipleParams) {\n    var regex = new RegExp('\\\\b' + newVarName + '\\\\b', 'g');\n    func = func.replace(regex, 'x');\n    return {\n      func: func,\n      numArgs: 1\n    };\n  } else if (newVarName && typeof newVarName === 'object' && multipleParams) {\n    numArgs = newVarName.length;\n    var ch = 'a';\n    for (var i = 0; i < newVarName.length; i++) {\n      var regex = new RegExp('\\\\b' + newVarName[i] + '\\\\b', 'g');\n      if (i === 0) {\n        func = func.replace(regex, 'x');\n      } else {\n        func = func.replace(regex, ch);\n        ch = String.fromCharCode(ch.charCodeAt(0) + 1);\n      }\n    }\n    return {\n      func: func,\n      numArgs: numArgs\n    };\n  }\n};\nParser.cleanFunc = function (func, newVarName, multipleParams) {\n  var f;\n  if (typeof func === 'function') {\n    f = Parser.extractFromFunction(func, multipleParams);\n  } else if (typeof func === 'string') {\n    f = Parser.extractFromString(func, newVarName, multipleParams);\n  } else {\n    throw 'function to be optimized needs to be a function or a string expression';\n  }\n  func = f.func;\n  var numArgs = f.numArgs;\n  func = func.replace(/Math./gi, '');\n  func = func.replace(/LN2/gi, 'ln(2)');\n  func = func.replace(/LN10/gi, 'ln(10)');\n  func = func.replace(/LOG2E/gi, 'log(e,2)');\n  func = func.replace(/LOG10E/gi, 'log(e,10)');\n  func = func.replace(/SQRT1_2/gi, 'sqrt(1/2)');\n  func = func.replace(/SQRT2/gi, 'sqrt(2)');\n  func = func.toLowerCase();\n  return {\n    func: func,\n    numArgs: numArgs\n  };\n};","map":{"version":3,"names":["Parser","module","exports","extractFromFunction","func","multipleParams","toString","args","arg","match","regex","RegExp","trim","replace","split","ch","i","length","String","fromCharCode","charCodeAt","numArgs","extractFromString","newVarName","cleanFunc","f","toLowerCase"],"sources":["C:/Users/Sagar/Desktop/Sensor/my-app/node_modules/scipy/optimize/node/parse.js"],"sourcesContent":["var Parser = module.exports = {};\n\nParser.extractFromFunction = function (func, multipleParams) {\n  // if function given is a function,\n  // extract the argument name, extract the return value,\n  // replace the argument name with 'x'\n  // return the return value as a string, with x as the independent variable\n  func = func.toString();\n  var args;\n  if (!multipleParams) {\n    var arg = func.match(/^function\\s*[^\\(]*\\(\\s*([^\\)\\,]*)[\\,\\)]/m)[1];\n    var regex = new RegExp('\\\\b' + arg.trim() + '\\\\b', 'g')\n    func = func.replace(regex, 'x');\n  } else {\n    // args are going to be f(x, a, b, c...) - x is independent variable, a, b... are parameters\n    args = func.match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)[\\)]/m)[1];\n    args = args.split(',');\n    var ch = 'a';\n    for (var i = 0; i < args.length; i++) {\n      var regex = new RegExp('\\\\b' + args[i].trim() + '\\\\b', 'g');\n      if (i === 0) {\n        func = func.replace(regex, 'x');\n      } else {\n        func = func.replace(regex, ch);\n        ch = String.fromCharCode(ch.charCodeAt(0) + 1);\n      }\n    }\n  }\n  func = func.match(/return\\s*([^\\;}]*)[\\;}]/m)[1];\n  args = args || {};\n  return {\n    func   : func, \n    numArgs: args.length\n  }\n};\n\nParser.extractFromString = function (func, newVarName, multipleParams) {\n  if (newVarName && typeof newVarName === 'string' && !multipleParams) {\n    var regex = new RegExp('\\\\b' + newVarName + '\\\\b', 'g');\n    func = func.replace(regex, 'x');\n    return {\n      func: func,\n      numArgs: 1\n    };\n  } else if (newVarName && typeof newVarName === 'object' && multipleParams) {\n    numArgs = newVarName.length;\n    var ch = 'a';\n    for (var i = 0; i < newVarName.length; i++) {\n      var regex = new RegExp('\\\\b' + newVarName[i] + '\\\\b', 'g');\n      if (i === 0) {\n        func = func.replace(regex, 'x');\n      } else {\n        func = func.replace(regex, ch);\n        ch = String.fromCharCode(ch.charCodeAt(0) + 1);\n      }\n    }\n    return {\n      func: func,\n      numArgs: numArgs\n    }\n  }\n}\n\nParser.cleanFunc = function (func, newVarName, multipleParams){\n  var f;\n  if (typeof func === 'function') {\n    f = Parser.extractFromFunction(func, multipleParams);\n  } else if (typeof func === 'string') {\n    f = Parser.extractFromString(func, newVarName, multipleParams);\n  } else {\n    throw 'function to be optimized needs to be a function or a string expression';\n  }\n  func = f.func;\n  var numArgs = f.numArgs;\n\n  func = func.replace(/Math./gi,'');\n  func = func.replace(/LN2/gi, 'ln(2)');\n  func = func.replace(/LN10/gi, 'ln(10)');\n  func = func.replace(/LOG2E/gi, 'log(e,2)');\n  func = func.replace(/LOG10E/gi, 'log(e,10)');\n  func = func.replace(/SQRT1_2/gi, 'sqrt(1/2)');\n  func = func.replace(/SQRT2/gi, 'sqrt(2)');\n  func = func.toLowerCase();\n\n  return {\n    func   : func,\n    numArgs: numArgs\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}